//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"compress/gzip"
	"encoding/binary"
	"fmt"
	"go/format"
	"os"
	"sort"
	"strings"
	"unicode"

	"github.com/cilium/ebpf/internal/btf"
)

func main() {
	if err := run(); err != nil {
		fmt.Fprintln(os.Stderr, "Error:", err)
		os.Exit(1)
	}
}

func run() error {
	fh, err := os.Open("../btf/testdata/vmlinux-btf.gz")
	if err != nil {
		return err
	}
	defer fh.Close()

	gz, err := gzip.NewReader(fh)
	if err != nil {
		return err
	}
	defer gz.Close()

	spec, err := btf.LoadRawSpec(gz, binary.LittleEndian)
	if err != nil {
		return err
	}

	output, err := generateTypes(spec)
	if err != nil {
		return err
	}

	formatted, err := format.Source(output)
	if err != nil {
		return err
	}

	w, err := os.Create("types.go")
	if err != nil {
		return err
	}
	defer w.Close()

	_, err = w.Write(formatted)
	return err
}

func generateTypes(spec *btf.Spec) ([]byte, error) {
	objName := &btf.Array{Nelems: 16, Type: &btf.Int{Encoding: btf.Char, Size: 1}}
	pointer := &btf.Int{Size: 8}

	gf := btf.NewGoFormatter()
	gf.Names = map[btf.Type]string{
		objName: "ObjName",
		pointer: "Pointer",
	}
	gf.Identifier = identifier
	gf.EnumIdentifier = func(name, element string) string {
		return element
	}

	w := bytes.NewBuffer(nil)
	w.WriteString(`// Code generated by gentypes.go; DO NOT EDIT.

package sys

import (
	"unsafe"
)

`)

	enums := []struct {
		id       string
		typeName string
	}{
		{"Cmd", "bpf_cmd"},
		{"MapType", "bpf_map_type"},
		{"ProgType", "bpf_prog_type"},
		{"AttachType", "bpf_attach_type"},
		{"LinkType", "bpf_link_type"},
		{"StatsType", "bpf_stats_type"},
		{"SkAction", "sk_action"},
		{"StackBuildIdStatus", "bpf_stack_build_id_status"},
		{"FunctionId", "bpf_func_id"},
		{"AdjRoomMode", "bpf_adj_room_mode"},
		{"HdrStartOff", "bpf_hdr_start_off"},
		{"RetCode", "bpf_ret_code"},
		{"XdpAction", "xdp_action"},
	}

	sort.Slice(enums, func(i, j int) bool {
		return enums[i].id < enums[j].id
	})

	enumTypes := make(map[string]btf.Type)
	for _, o := range enums {
		t, err := spec.Find(o.typeName)
		if err != nil {
			return nil, err
		}

		if _, ok := t.(*btf.Enum); !ok {
			return nil, fmt.Errorf("type %q is not an enum", o.typeName)
		}

		if name := gf.Names[t]; name != "" {
			return nil, fmt.Errorf("type %q is already declared as %s", o.typeName, name)
		}
		gf.Names[t] = o.id
		enumTypes[o.id] = t

		decl, err := gf.TypeDeclaration(o.id, t)
		if err != nil {
			return nil, fmt.Errorf("generate %q: %w", o.id, err)
		}

		w.WriteString(decl)
		w.WriteRune('\n')
	}

	// Assorted structs

	structs := []struct {
		id       string
		typeName string
		patches  []patch
	}{
		{
			"ProgInfo", "bpf_prog_info",
			[]patch{replace(objName, "name"), replace(pointer, "map_ids")},
		},
		{
			"MapInfo", "bpf_map_info",
			[]patch{replace(objName, "name")},
		},
		{
			"BtfInfo", "bpf_btf_info",
			[]patch{replace(pointer, "btf", "name")},
		},
		{
			"LinkInfo", "bpf_link_info",
			[]patch{
				replace(enumTypes["LinkType"], "type"),
				truncateAfter("prog_id"),
			},
		},
		{"FuncInfo", "bpf_func_info", nil},
		{"LineInfo", "bpf_line_info", nil},
	}

	sort.Slice(structs, func(i, j int) bool {
		return structs[i].id < structs[j].id
	})

	for _, s := range structs {
		var t btf.Struct
		if err := spec.FindType(s.typeName, &t); err != nil {
			return nil, err
		}

		if err := outputPatchedStruct(gf, w, s.id, &t, s.patches); err != nil {
			return nil, fmt.Errorf("output %q: %w", err)
		}
	}

	// Attrs

	attrs := []struct {
		id       string
		typeName string
		cmd      string
		patches  []patch
	}{
		{
			"MapCreate", "map_create", "BPF_MAP_CREATE",
			[]patch{
				replace(objName, "map_name"),
				replace(enumTypes["MapType"], "map_type"),
			},
		},
		{
			"MapLookupElem", "map_elem", "BPF_MAP_LOOKUP_ELEM",
			[]patch{choose(2, "value"), replace(pointer, "key", "value")},
		},
		{
			"MapLookupAndDeleteElem", "map_elem", "BPF_MAP_LOOKUP_AND_DELETE_ELEM",
			[]patch{choose(2, "value"), replace(pointer, "key", "value")},
		},
		{
			"MapUpdateElem", "map_elem", "BPF_MAP_UPDATE_ELEM",
			[]patch{choose(2, "value"), replace(pointer, "key", "value")},
		},
		{
			"MapDeleteElem", "map_elem", "BPF_MAP_DELETE_ELEM",
			[]patch{choose(2, "value"), replace(pointer, "key", "value")},
		},
		{
			"MapGetNextKey", "map_elem", "BPF_MAP_GET_NEXT_KEY",
			[]patch{
				choose(2, "next_key"), replace(pointer, "key", "next_key"),
				truncateAfter("next_key"),
			},
		},
		{
			"MapFreeze", "map_elem", "BPF_MAP_FREEZE",
			[]patch{truncateAfter("map_fd")},
		},
		{
			"MapLookupBatch", "map_elem_batch", "BPF_MAP_LOOKUP_BATCH",
			[]patch{replace(pointer, "in_batch", "out_batch", "keys", "values")},
		},
		{
			"MapLookupAndDeleteBatch", "map_elem_batch", "BPF_MAP_LOOKUP_AND_DELETE_BATCH",
			[]patch{replace(pointer, "in_batch", "out_batch", "keys", "values")},
		},
		{
			"MapUpdateBatch", "map_elem_batch", "BPF_MAP_UPDATE_BATCH",
			[]patch{replace(pointer, "in_batch", "out_batch", "keys", "values")},
		},
		{
			"MapDeleteBatch", "map_elem_batch", "BPF_MAP_DELETE_BATCH",
			[]patch{replace(pointer, "in_batch", "out_batch", "keys", "values")},
		},
		{
			"ProgLoad", "prog_load", "BPF_PROG_LOAD",
			[]patch{
				replace(objName, "prog_name"),
				replace(enumTypes["ProgType"], "prog_type"),
				replace(enumTypes["AttachType"], "expected_attach_type"),
				replace(pointer, "insns", "license", "log_buf", "func_info", "line_info"),
			},
		},
		{
			"ObjPin", "obj_pin", "BPF_OBJ_PIN",
			[]patch{replace(pointer, "pathname")},
		},
		{
			"ObjGet", "obj_pin", "BPF_OBJ_GET",
			[]patch{replace(pointer, "pathname")},
		},
		{
			"ProgAttach", "prog_attach", "BPF_PROG_ATTACH",
			nil,
		},
		{
			"ProgDetach", "prog_attach", "BPF_PROG_DETACH",
			[]patch{truncateAfter("attach_type")},
		},
		{
			"ProgRun", "prog_run", "BPF_PROG_TEST_RUN",
			[]patch{replace(pointer, "data_in", "data_out", "ctx_in", "ctx_out")},
		},
		{
			"ProgGetNextId", "obj_next_id", "BPF_PROG_GET_NEXT_ID",
			[]patch{
				choose(0, "start_id"), rename("start_id", "id"),
				truncateAfter("next_id"),
			},
		},
		{
			"MapGetNextId", "obj_next_id", "BPF_MAP_GET_NEXT_ID",
			[]patch{
				choose(0, "start_id"), rename("start_id", "id"),
				truncateAfter("next_id"),
			},
		},
		// These piggy back on the obj_next_id decl, but only support the
		// first field...
		{
			"BtfGetFdById", "obj_next_id", "BPF_BTF_GET_FD_BY_ID",
			[]patch{choose(0, "start_id"), rename("start_id", "id"), truncateAfter("id")},
		},
		{
			"MapGetFdById", "obj_next_id", "BPF_MAP_GET_FD_BY_ID",
			[]patch{choose(0, "start_id"), rename("start_id", "id"), truncateAfter("id")},
		},
		{
			"ProgGetFdById", "obj_next_id", "BPF_PROG_GET_FD_BY_ID",
			[]patch{choose(0, "start_id"), rename("start_id", "id"), truncateAfter("id")},
		},
		{
			"ObjGetInfoByFd", "info_by_fd", "BPF_OBJ_GET_INFO_BY_FD",
			[]patch{replace(pointer, "info")},
		},
		// {
		// 	"ProgQuery", "prog_query",
		// 	[]patch{replace(pointer, "prog_ids")},
		// },
		{
			"RawTracepointOpen", "raw_tracepoint_open", "BPF_RAW_TRACEPOINT_OPEN",
			[]patch{replace(pointer, "name")},
		},
		{
			"BtfLoad", "btf_load", "BPF_BTF_LOAD",
			[]patch{replace(pointer, "btf", "btf_log_buf")},
		},
		{
			"LinkCreate", "link_create", "BPF_LINK_CREATE",
			[]patch{replace(enumTypes["AttachType"], "attach_type")},
		},
		{
			"LinkCreateIter", "link_create", "BPF_LINK_CREATE",
			[]patch{
				chooseNth(4, 1),
				replace(enumTypes["AttachType"], "attach_type"),
				flattenAnon,
				replace(pointer, "iter_info"),
			},
		},
		{
			"LinkUpdate", "link_update", "BPF_LINK_UPDATE",
			nil,
		},
		// {
		// 	"LinkDetach", "link_detach", "",
		// 	nil,
		// },
		{
			"EnableStats", "enable_stats", "BPF_ENABLE_STATS",
			nil,
		},
		{
			"IterCreate", "iter_create", "BPF_ITER_CREATE",
			nil,
		},
		// {
		// 	"ProgBindMap", "prog_bind_map", "",
		// 	nil,
		// },
	}

	sort.Slice(attrs, func(i, j int) bool {
		return attrs[i].id < attrs[j].id
	})

	attrTypes, err := splitBpfAttr(spec)
	if err != nil {
		return nil, fmt.Errorf("splitting bpf_attr: %w", err)
	}

	for _, s := range attrs {
		t := attrTypes[s.typeName]
		if t == nil {
			return nil, fmt.Errorf("unknown attr %q", s.typeName)
		}

		id := s.id + "Attr"
		if err := outputPatchedStruct(gf, w, id, t, s.patches); err != nil {
			return nil, fmt.Errorf("output %q: %w", id, err)
		}

		fmt.Fprintf(w, "func (a *%s) cmd() (Cmd, unsafe.Pointer, uintptr) { return %s, unsafe.Pointer(a), unsafe.Sizeof(*a) }\n\n", id, s.cmd)
	}

	return w.Bytes(), nil
}

func outputPatchedStruct(gf *btf.GoFormatter, w *bytes.Buffer, id string, s *btf.Struct, patches []patch) error {
	cpy, _ := btf.CopyType(s, nil)
	s = cpy.(*btf.Struct)

	for i, p := range patches {
		if err := p(s); err != nil {
			return fmt.Errorf("patch %d: %w", i, err)
		}
	}

	decl, err := gf.TypeDeclaration(id, s)
	if err != nil {
		return err
	}

	w.WriteString(decl)
	w.WriteString("\n\n")
	return nil
}

func splitBpfAttr(spec *btf.Spec) (map[string]*btf.Struct, error) {
	var bpfAttr btf.Union
	if err := spec.FindType("bpf_attr", &bpfAttr); err != nil {
		return nil, err
	}

	types := []struct {
		name                  string
		typeOrFirstMemberName string
	}{
		{"map_create", "map_type"},
		{"map_elem", "map_fd"},
		{"map_elem_batch", "batch"},
		{"prog_load", "prog_type"},
		{"obj_pin", "pathname"},
		{"prog_attach", "target_fd"},
		{"prog_run", "test"},
		{"obj_next_id", ""},
		{"info_by_fd", "info"},
		{"prog_query", "query"},
		{"raw_tracepoint_open", "raw_tracepoint"},
		{"btf_load", "btf"},
		{"task_fd_query", "task_fd_query"},
		{"link_create", "link_create"},
		{"link_update", "link_update"},
		{"link_detach", "link_detach"},
		{"enable_stats", "enable_stats"},
		{"iter_create", "iter_create"},
		{"prog_bind_map", "prog_bind_map"},
	}

	structs := make(map[string]*btf.Struct)

	for i, t := range types {
		member := bpfAttr.Members[i]

		s, ok := member.Type.(*btf.Struct)
		if !ok {
			return nil, fmt.Errorf("%q: %s is not a struct", t.name, member.Type)
		}

		if member.Name == "" {
			if name := s.Members[0].Name; name != t.typeOrFirstMemberName {
				return nil, fmt.Errorf("first field of %q is %q, not %q", t.name, name, t.typeOrFirstMemberName)
			}
		} else if member.Name != t.typeOrFirstMemberName {
			return nil, fmt.Errorf("name for %q is %q, not %q", t.name, member.Name, t.typeOrFirstMemberName)
		}

		structs[t.name] = s
	}

	return structs, nil
}

// TODO No copypasta
func identifier(str string) string {
	prev := rune(-1)
	return strings.Map(func(r rune) rune {
		// See https://golang.org/ref/spec#Identifiers
		switch {
		case unicode.IsLetter(r):
			if prev == -1 {
				r = unicode.ToUpper(r)
			}

		case r == '_':
			switch {
			// The previous rune was deleted, or we are at the
			// beginning of the string.
			case prev == -1:
				fallthrough

			// The previous rune is a lower case letter or a digit.
			case unicode.IsDigit(prev) || (unicode.IsLetter(prev) && unicode.IsLower(prev)):
				// delete the current rune, and force the
				// next character to be uppercased.
				r = -1
			}

		case unicode.IsDigit(r):

		default:
			// Delete the current rune. prev is unchanged.
			return -1
		}

		prev = r
		return r
	}, str)
}

type patch func(*btf.Struct) error

func member(name string, fn func(*btf.Member) error) patch {
	return func(s *btf.Struct) error {
		for i, m := range s.Members {
			if m.Name == name {
				return fn(&s.Members[i])
			}
		}
		return fmt.Errorf("%q is not a member", name)
	}
}

func members(fn func(*btf.Member) error, names ...string) patch {
	return func(s *btf.Struct) error {
		want := make(map[string]bool)
		for _, name := range names {
			want[name] = true
		}

		for i, m := range s.Members {
			if want[m.Name] {
				if err := fn(&s.Members[i]); err != nil {
					return err
				}
				delete(want, m.Name)
			}
		}

		if len(want) == 0 {
			return nil
		}

		var missing []string
		for name := range want {
			missing = append(missing, name)
		}
		sort.Strings(missing)

		return fmt.Errorf("missing members: %v", strings.Join(missing, ", "))
	}
}

func replace(t btf.Type, names ...string) patch {
	return members(func(m *btf.Member) error {
		m.Type = t
		return nil
	}, names...)
}

func choose(member int, name string) patch {
	return nthMember(member, func(m *btf.Member) error {
		union, ok := m.Type.(*btf.Union)
		if !ok {
			return fmt.Errorf("member %d is %s, not a union", member, m.Type)
		}

		for _, um := range union.Members {
			if um.Name == name {
				m.Name = um.Name
				m.Type = um.Type
				return nil
			}
		}

		return fmt.Errorf("%s has no member %q", union, name)
	})
}

// TODO: This is really brittle.
func chooseNth(member int, n int) patch {
	return nthMember(member, func(m *btf.Member) error {
		union, ok := m.Type.(*btf.Union)
		if !ok {
			return fmt.Errorf("member %d is %s, not a union", member, m.Type)
		}

		if n >= len(union.Members) {
			return fmt.Errorf("member %d is out of bounds", n)
		}

		um := union.Members[n]
		m.Name = um.Name
		m.Type = um.Type
		return nil
	})
}

func flattenAnon(s *btf.Struct) error {
	for i := range s.Members {
		m := &s.Members[i]

		cs, ok := m.Type.(*btf.Struct)
		if !ok || cs.Name != "" {
			continue
		}

		for j := range cs.Members {
			cs.Members[j].OffsetBits += m.OffsetBits
		}

		newMembers := make([]btf.Member, 0, len(s.Members)+len(cs.Members)-1)
		newMembers = append(newMembers, s.Members[:i]...)
		newMembers = append(newMembers, cs.Members...)
		newMembers = append(newMembers, s.Members[i+1:]...)

		s.Members = newMembers
	}

	return nil
}

func nthMember(member int, fn func(*btf.Member) error) patch {
	return func(s *btf.Struct) error {
		if member >= len(s.Members) {
			return fmt.Errorf("member %d is out of bounds", member)
		}

		return fn(&s.Members[member])
	}
}

func truncateAfter(name string) patch {
	return func(s *btf.Struct) error {
		for i, m := range s.Members {
			if m.Name != name {
				continue
			}

			size, err := btf.Sizeof(m.Type)
			if err != nil {
				return err
			}

			s.Members = s.Members[:i+1]
			s.Size = (m.OffsetBits / 8) + uint32(size)
			return nil
		}

		return fmt.Errorf("no member %q", name)
	}
}

func rename(from, to string) patch {
	return func(s *btf.Struct) error {
		for i, m := range s.Members {
			if m.Name == from {
				s.Members[i].Name = to
				return nil
			}
		}
		return fmt.Errorf("no member named %q", from)
	}
}
